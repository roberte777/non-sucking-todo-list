use std::io::Stdout;

use tui::{
    layout::{Alignment, Constraint, Direction, Layout},
    style::{Color, Style},
    text::{Span, Spans},
    widgets::{Block, BorderType, Borders, Paragraph},
    Frame,
};

use crate::inputs::keys::Key;

use super::{
    actions::{Action, Actions},
    ui::check_size,
    App, AppReturn,
};

pub trait State {
    fn do_action(&mut self, key: Key) -> AppReturn;
    fn draw(&self, rect: &mut Frame<tui::backend::CrosstermBackend<Stdout>>, app: &App);
}
pub struct EditingState {}
impl EditingState {
    pub fn new() -> Box<Self> {
        return Box::new(Self {});
    }
}
impl State for EditingState {
    fn do_action(&mut self, key: Key) -> AppReturn {
        todo!()
    }
    fn draw(&self, rect: &mut Frame<tui::backend::CrosstermBackend<Stdout>>, app: &App) {
        todo!()
    }
}
//TODO: Too complicated for first app. Instead of doing this, just have
//a mapping of keys to action enum. Then, in do_action, do stuff based on that
//action enum. Simplify this later, don't do it first
pub struct ListState {
    actions: Actions,
    selected: u32,
}
impl ListState {
    pub fn new() -> Box<Self> {
        let actions = vec![Action::Quit].into();
        return Box::new(Self {
            actions,
            selected: 0,
        });
    }
    pub fn test(&self) {
        println!("test")
    }
}
impl State for ListState {
    fn do_action(&mut self, key: Key) -> AppReturn {
        test(self);
        if let Some(action) = self.actions.find(key) {
            match action {
                Action::Quit => AppReturn::Exit,
            }
        } else {
            return AppReturn::Continue;
        }
    }
    fn draw(&self, rect: &mut Frame<tui::backend::CrosstermBackend<Stdout>>, app: &App) {
        let size = rect.size();
        check_size(&size);
        let chunks = Layout::default()
            .direction(Direction::Vertical)
            .constraints([Constraint::Length(3), Constraint::Min(50)].as_ref())
            .split(size);
        let title = Paragraph::new("TODO List")
            .style(Style::default().fg(Color::LightCyan))
            .alignment(Alignment::Center)
            .block(
                Block::default()
                    .borders(Borders::ALL)
                    .style(Style::default().fg(Color::White))
                    .border_type(BorderType::Plain),
            );

        rect.render_widget(title.clone(), chunks[0]);
        let body_content: Vec<Span> = app
            .list
            .iter()
            .enumerate()
            .map(|(i,item)| {
                if item.
                return Span::styled(item.content.clone(), Style::default());
            })
            .collect();
        let body_paragraph = Paragraph::new(Spans::from(body_content)).block(
            Block::default()
                .borders(Borders::ALL)
                .style(Style::default())
                .border_type(BorderType::Plain),
        );

        rect.render_widget(body_paragraph, chunks[1]);
    }
}
pub fn test(t: &mut ListState) {}
